## chapter9 전문 검색기술 도전 <sub>대규모 데이터 처리의 노하우</sub>

> 대규모 데이터를 다 떠안지 못하게 된 데이터베이스의 한계를 검색 시스템으로 돌파하는 방안도 있다. 이것이 chapter 5에서 예기했던 용도 특화형 인덱싱의 한 예이다. 

- 검색이라고 하면 Google이나 Naver 같은 검색 서비스를 상상할 수도 있지만, 그렇지 않은 상황에서 검색기술을 응용한다는 것이 중요 포인트이다. 

#### 

리눅스에서 자주 사용하는 grep 또한 생각하기에 따라서는 전문 검색이다. 디렉토리를 지정해서 해당 디렉토리에 있는 문서를 전부 살펴보고 원하는 단어가 포함되어 있는 문서를 찾아주기 때문이다. 

Apache Lucene, Senna 등 다앙한 검색엔진이 있다. 

#### 다양한 검색엔진

- grep 형

  - 검색 대산 문서를 처음부터 전부 읽어가는, 가장 단순한 아키텍쳐이다. 단순하고 고지식하게 구현하면, 검색 대상 텍스트의 길이를 m, 검색어의 길이를 n 이라고 했을 때 O(mn)만큼 걸린다. 데이터의 크기에 따라 상당히 오래 걸릴 수도 있다.
  - 하지만 즉시성이 좋고, 문서가 갱신되더라도 바로 검색할 수 있으며, 검색누락이 없다. 
  - 또한 병렬화하기가 간단하다. (예)매우 긴 문서를 검색할 때 분할해서 병렬로 검색할 수도 있다.)
  - 쿼리에 정규표현이 가능해서 사용할때의 간편함도 한 몫 한다.

- Suffix형

  - 문서를 검색 가능한 형태(Trie 구조나 Suffix Array, Suffix Tree 등)로 가공하여 가지고 있다. 
  - 검색에 효율적인 구조로 변경하여 가지고 있으므로 메모리에 올리기 용이하다.
  - **하지만 구조를 변경하면 메모리에 올리기 용이하다고는 하나, 일반적으로 데이터 량이 커지기 때문에(sub 작업이 이루어지므로) 실제 이 아키텍쳐를 가진 엔진은 좀처럼 구현하기 힘들다.**

- 역 인덱스형

  - 역 인덱스 : 간단히 말하면, 문서에서 검색될 만한 것들의 존재여부와 위치를 미리 추출하여 탐색구조를 구축해 놓고 추출된 것을 통해 검색하는 방식이다.

  - term(단어)와 문서를 연관짓는 것이다. 

    - 만일 서비스 내부에서 '아이폰' 이라는 단어가 포함된 문서가 1,3,4 번 페이지에 있다면

      아이폰 -> 1 | 3 | 4 

      와 같은 형식으로 저장한다. 아이폰으로 검색한 결과로 1, 3, 4 페이지의 내용이 나타나는 것이다.

  - term의 집합이 바로 Dictionary(사전) 이다.

  - 역 인덱스 방식은 역 인덱스를 문서와는 별개로 전처리로 만들어둬야 한다. 따라서 grep과 같이 문서가 변경되면 바로 검색결과도 바뀌는 형태의 구현은 할 수 없다.

  - **하지만 인덱스를 압축함으로써 컴팩트하게 가져갈 수 있고 대규모화하기도 쉽다. 또한 구현도 적절한 수준으로 할 수 있어 밸런스도 좋은 아키텍처이다.** 따라서 현재 검색 엔진의 주류 아키텍쳐라고 할 수 있다.

_ _ _

