## chapter 4. 분산을 고려한 MySQL 운용

> 국소성을 고려하고, 데이터 규모에 맞게 탑재 메모리를 조정하고, 메모리 증설로도 대응할 수 없을 경우에는 분산하라는 것이 지금까지 한 설명의 주된 흐름이었다. chapter 4에서는 DB레이어로 얘기를 옮겨서 DB 스케일아웃 전략에 대해 자세히 알아보도록 하자.

###분산을 고려한 MySQL 운용, 세 가지 포인트

1. OS캐시 활용

   chapter 3의 확장 내용이다. chapter 3을 통해 OS 캐시의 특성을 알고 난 뒤이기 때문에 메모리에서 캐시하는 과정을 이해한다면 따로 자세한 이해는 필요없이 읽는 것만으로 도움이 될 것이다. 

2. 인덱스 활용

   DB의 인덱스(색인)을 활용하는 것으로 원래 Table로부터 인덱싱된 값을 활용하여 더욱 빠르게 검색하는 것이다.

3. 확장을 한다는 전제로 시스템을 설계해둔다.

   애초에 시스템 설계 당시에 확장하기 편하도록 설계할 수 있는 법에 대해 자세히 다룰 것이다.



#### OS 캐시 활용

주요 골자는 전체 데이터 크기에 주의해서 데이터량이 물리 메모리보다 가능한 한 적어지도록 유지한다. 메모리가 부족할 경우 증설한다. 증설에 관한 판단은 chapter 3.을 다시 참조하길 바란다.

- MySQL에서는 create table로 스키마를 작성한다. 만일, 레코드가 3억개 정도 되고, 레코드의 칼럼을 추가해야할 일이 생긴다고 하자. 이 때, 칼럼의 데이터가 8Byte 정도 된다고 하면 8X3억, 즉 대략 3GB 정도의 데이터가 추가된다. 기존 스키마에서 조금의 변경을 가하는 것으로도 엄청난 데이터가 증가될 수 있다. 
- 이 때 만일 저장되는 데이터 값의 용량에 대한 숫자 감각이 있다면, 메모리의 용량을 얼만큼 추가해야 되는지 대략적인 계산이 이루어 질 수 있다. 
  - 정수형 int는 32bits———> 4Bytes
  - 문자열 8bits ———> 1byte
  - 이를 감안하여 계산하면 하나의 레코드가 차지하는 용량을 확인할 수 있다. 이를 통해 OS가 캐시 가능한 용량과 비교하여 적절히 메모리를 늘릴 수 있다.

> OS 캐시 활용
>
> - 전체 데이터 크기에 주의
>
>   -> '데이터량 < 물리 메모리' 를 유지
>
>   -> 메모리가 부족할 경우에는 증설 등
>
> - 스키마 설계가 데이터 크기에 미치는 영향을 고려한다.

- 정규화

  정규화를 통해 한 레코드가 차지하는 칼럼 수를 줄인다면, 그만큼의 용량이 줄어들 수 있다. 하지만 이 때 조심해야 할 것이 있는데, 경우에 따라서는 쿼리가 복잡해져서 속도가 떨어지는 경우가 생긴다. 이 때 발생하는 트레이드오프(trade-off) 와 같은 부분을 잘 생각하여야 한다. 하지만단순히 값을 얻어오는 행위만 하는 테이블의 경우 정규화를 진행하는게 대체적으로 좋다.

#### 인덱스의 중요성 - B트리

- 알고리즘, 데이터 구조에서 탐색을 할 때는 기본적으로 트리(탐색트리)가 널리 사용된다. 이는 부모와 자식 노드 간의 계층 형성이 이루어져 더욱 탐색을 쉽게 할 수 있는 이유 때문으로, 충분히 상식적으로 납득 가능할 것이다. 
- MySQL의 인덱스는 기본적으로 B+tree라는 데이터 구조를 활용하며 이는 B트리에서 더욱 확장 된 개념이다.
- B트리나, B+트리에서 인덱스 컬럼을 선정하고, 이를 통해 B트리 구조를 이룸으로써 탐색 속도를 올릴 수 있다.

##### B트리란? , B+트리란?

이진 탐색트리 (Binaty Search Tree)의 응용 버전으로 이진탐색트리에서 자식 노드의 수를 최대 2개가 아닌 그 이상으로 설정할 수 있다. 이는 결국 노드의 데이터 용량을 하드디스크와 같은 기억장치가 읽을 수 있는 블럭의 용량과 최대한 같게 맞추어 줄 수 있어 한번 seek에 한 노드씩 검색할 수 있게 만드는게 큰 장점이 있기에 데이터베이스의 인덱싱 작업에 많이 사용된다. B트리의 자세한 내용은 아래 링크를 첨부하며, 실제 b트리를 만들어볼 수 있는 링크까지 첨부한다.

- B트리 [자세히보기](<https://wangin9.tistory.com/entry/B-tree-B-tree>)
- B트리 그려보기 [바로가기](<https://www.cs.usfca.edu/~galles/visualization/BTree.html>)

B트리에서는, 만일 중간에 노드가 추가되어야 하는 상황이 되면, 전체 트리의 구조가 변화해야하는 문제가 발생할 수 있다. 결국 이에 소모되는 연산시간이 발생하기 마련이고 이를 줄이기 위해 제일 아래의 leaf 노드들에 모든 노드의 연결을 리스트 형태로 만들어두고, leaf노드가 아닌 노드들의 경우는 단지 이동하는 분기값으로 활용되기만 한다. 결국 검색은 맨 아래의 leaf노드에서 이루어지며, 중간의 분기값 또한 리스트로 저장되어 있기 때문에 검색이 용이하다. 그리고 노드를 추가하는 상황에서도 leaf노드의 숫자만 변경될 뿐, 그 중간의 노드들의 개수는 변경되지 않는 장점이 있다. 이는 추후에 더욱 자세히 학습한다.



##### 이분트리와 B트리 비교

결국 B트리가 데이터베이스의 인덱싱에 사용될 수 있는 이유는 이분트리에서는 노드의 데이터량을 임의로 정의할 수 없지만, B트리는 가능하다는 것이다. 결국 디스크가 읽히는 블럭(페이지) 단위로 한 노드의 데이터양을 조절하게 되면 결과적으로 디스크로 seek하는 횟수를 효과적으로 줄일 수 있다. 



##### 인덱스 효과의 예

4000만의 데이터를 탐색할 때, 인덱스가 없다면 최악의 경우 4000만 번 모두 순회하며 데이터를 찾아야 한다. 하지만 만일 인덱스가 있을 경우에는 O(logn), 즉 25.25번만에 데이터를 찾을 수 있게 된다. 

이 때 주의깊게 봐야 할 점은, 트리를 한번 순회하는데 오버헤드가 발생할 수 있다는 것이다. 데이터의 양이 많다면 이 오버헤드는 충분히 무시 가능한 수준이지만 만일 데이터 건수가 1000건 정도라면 인덱스를 활용하지 않고 바로 탐색하는 것이 더 빠를 수도 있다. **MySQL은 레코드 총 건수를 보고 인덱스를 사용하지 않는 편이 더 빠르다라고 판단되면, 사용하지 않는 최적화 작업을 내부에서 어느 정도 수행한다.**



**참고!!!!!!!!**

인덱스 컬럼의 설정은 카디널리티(Cadinality)가 높은 컬럼을 설정하는 것이 좋다. 트리화 하였을 때, 중복도가 낮아 적절히 데이터를 분산하여 트리화 할 수 있기 때문이다. **추가 학습 필요**

#####인덱스가 작용하는지 확인하는 법 - explain 명령

인덱스가 작용하고 있는 지는 explain명령을 통해 확인할 수 있다.

~~~MySql
mysql> explain select url from entry where edi = 96158990;
mysql> explain select url from entry use index(cname) where eid = 9615899;
~~~

이 명령어를 통해 나오는 값 중 *possible_keys* 는 인덱스의 값으로 사용될 가능성이 있는 값, 그리고 *key*의 값이실제로 사용된 인덱스의 값이다. 하테나의 예시에서는 위의 쿼리는 인덱스를 통해 실제로 검색하는 것을 나타내고, 아래의 쿼리는 일부러 테이블에 존재하지 않는 키값을 인덱스로 설정해서 인덱스가 작용하지 않게 한 것이다. 결국 위의 쿼리는 row 하나만에 결과를 찾았고, 아래의 경우 전체 row인 9620451번 수행하여 찾았다.

- possible_keys : 인덱스 값으로 사용될 가능성이 있는 키
- Key : 실제 인덱스로 사용된 컬럼의 이름
- Extra : Using where 이외에 다른 값이 올 수 있는데, 외부의 정렬을 사용한 경우이다. 이는 임시 테이블이나 외부 정렬부분이 필요하므로, 쿼리나 인덱스를 튜닝해야할 필요가 있다. 



#### MySQL의 레플리케이션 기능

- 데이터 서버를 Master와 Slave로 나누어 관리한다. 

  ![master-slave](https://www.solidres.com/blog/wp-content/uploads/2019/01/master_slave_mode.png)

- Slave들은 Master의 내용을 복사하여 가지고 있는다. 통상적으로 Master는 하나의 서버로 운용하고, 만일 데이터의 갱신 쿼리(insert, update 등)가 이뤄질 경우 Master로, 단지 참조 쿼리(select 등)가 이뤄질 경우 Slave로 접촉한다. 갱신쿼리를 통해 Master에서 데이터의 변경이 이뤄지면 모든 Slave는 Polling(Master와 싱크 맞추는 것)작업을 수행한다.
- MySQL Proxy - 더 찾아보기



##### Master 는 분산할 수 없는가?

- 반드시 할 수 없는 것은 아니지만, 갱신 쿼리가 늘어나면 상당히 험난해진다. 하지만 웹 애플리케이션의 특성상 90% 정도의 쿼리는 항상 참조계열 쿼리이다. 그러므로 웹 서비스에서는 Master를 하나만 두어도 충분히 가능하다.
- 하지만 만일! 갱신쿼리가 많아져 Master를 분할해야 한다면 테이블 분할이나 다른 방법의 연구가 있다. 이는 추후에 학습한다.

##### RDBMS를 사용하지 않는 방법도 있는가?

- 단순히 key-value로 데이터가 저장될 수 있고, 저장된 값을 꺼내보기만 하는 경우, 굳이 RDBMS가 아닌, key-value 기반의 스토어를 활용하면 쉽게 운용할 수도 있다. 운용하는 서비스에 알맞는 데이터베이스 모델을 선택하는 것, 그리고 여러가지를 동시에 사용한다면, 최대한 효율을 발휘할 수 있는 목적으로 해야할 것이다. 

#### MySQL의 스케일아웃과 파티셔닝

**지금까지의 개념 정리** : 기본적인 스케일 아웃 전략으로는 데이터가 메모리에 올라가는 크기이면 메모리에 올리고, 올라가지 않으면 메모리를 증설하는 것이었다. 그리고 '인덱스는 제대로 걸자'이다. chapter 3. 의 마지막에서 잠깐 살펴본 DB 파티셔닝에 대해 더 자세히 알아보도록 하자.

##### 파티셔닝이란?

테이블 A와 테이블 B를 서로 다른 서버에 놓아서 분산하는 것. 아래의 그림을 생각하면 쉽다.

![파티셔닝](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQPnTqMzKv4qQzWVJY2JzYEkFIBnowRk5X0yLFtm29XzzRe9KckkA)

**국수성을 활용하여 분산할 수 있으므로 캐시가 유효해서 효과적이다.** 지금까지 학습을 통해 이 말이 주는 의미를 좀 더 명쾌하게 해석할 수 있었다. 



##### 파티셔닝을 전제로 한 설계

장황한 설명을 통해 해설하고 있지만, 쉽게 얘기하자면, 두 가지의 관점에서 바라보면 좋을 것 같다.

1. 애초에 밀접한 관계를 가진 테이블 들이 파티셔닝 되어있는 상태이고 이 때에, JOIN 쿼리와 같이 두 테이블이 연관 된 값을 얻고자 할 때
2. 서비스의 비즈니스 중 애초에 하나의 서버에서 관리중이라 Join 쿼리를 사용했고, 추후에 파티셔닝을 통해 나뉘어진 테이블이 되어 이를 수정해야 할 때

뒤의 해설에도 나오지만, 사실 RDBMS의 관점에서 본다면, 1.을 위해 JOIN문을 최대한 배제한다는 것은 RDBMS의 사용 의의가 크게 떨어진다고 할 수 있다. 그리고 2.의 경우 서비스가 변화함에 따라 이에 능동적으로 대응해야하는 것의 중요성을 말하고 있다. 웹 프로그래머가 가져야 할 가장 중요한 덕목 중에 하나라고 생각하는 점을 다시 한번 되짚을 수 있다. 

**중요한 것은, 어떤 변화에도 능동적으로 수용할 수 있어야 한다는 자세가 아닐까?**

하테나의 경우 수많은 데이터가 존재하과, 이 데이터들의 연결관계가 정의된 문서가 있긴 하지만, 최대한 JOIN을 배제함으로써 파티셔닝이 이루어 지더라도, 충분히 데이터를 JOIN하여 얻는 것과 같은 효과를 내기 위해 노력하고 있다. 그것이 바로 DBIx::MoCo와 같은 O/R매퍼를 활용하는 것이다. 이를 사용하면 두 개의 테이블에 걸친 API를 호출했을 때, 내부적으로 JOIN을 사용하지 않고, 두 개의 쿼리로 나누어 계산하게 된다. 하지만 경우에 따라서는 오버헤드가 아까워 직접 SQL을 사용하기도 한다. 이 때 JOIN에 대한 기본 개념을 알아두면 편리하다.

- 하테나의 경우!!
  - O/R매퍼를 통해 JOIN문의 경우 두 개의 쿼리를 자동으로 나누어서 계산할 수 있도록 매핑 시켜놓는다.
  - 하지만 혹시라도 오버헤드가 걱정되어 JOIN을 사용해야 할 때, 기본 학습이 되어있어야 한다.

#### 파티셔닝의 상반관계

> 파티셔닝의 좋은 점은 부하가 내려가고 국소성이 늘어나서 캐시 효과가 높아진다는 점이었다. 한편으로는 나쁜점도 물론 있다.

- 운용이 복잡해진다.

  아무래도 관리해야 할 서버의 대수가 늘어나며, 이에 따라 이 서버는 무슨일을 하는지, 저 서버는 무슨 일을 하는지에 대해 파악하는 것이 힘들다.

- 고장률이 높아진다.

  대수가 늘어나면 비율 상으로 고장의 비율 또한 늘어나게 된다. 이 고장과 관련해서는 중요한 개념이 한 가지 있다.

  - 기본적으로 우리가 생각하는 DB서버는 여러 대의 서버를 하나의 큰 틀로 관리하고, 그것을 DB 서버의 한 단위라고 생각해야 한다. 앞서 살펴 본 Master-Slave 구조가 그것이다. Master-Slave 구조의 경우, 요청을 분산하는 장점도 있지만, 데이터를 여러 대의 Slave로 나눠 관리함으로써 백업하는 효과까지 거둘 수 있다. 만일 Master가 먹통이 되면 Slave 중에 하나를 Master로 승격시키면 된다.
  - 이 때, 서버를 분할하여 2개의 서버로 분할하였다고 하자. 기본적으로 한 서버 단위에는 Master-Slave 구조로 4개의 서버가 운용된다(왜 하필 4대인지는 아래에서 다시 설명한다). 결국 서버 단위를 2개로 늘린다는 것은 4개에서 8개로 늘린다는 말이다. 

- **왜 하필 Master-Slave는 최소 4대일까? ( Masger 1, Slave 3)**

  DB서버는 서비스가 운용되고 있는 한 절대 멈추어서는 안된다는 개념을 기본적으로 가져야 한다. 그리고 다시 원상복구 시켜야 한다. 만약 3대로 운용한다고 가정하자(Master 1, Slave 2). 이 때, Master가 고장이 나면 Slave 하나가 자동으로 Master로 승격된다. 그러면 (Master1, Slave1)의 구조를 가지게 된다. 이 때, 다시 원상복구 시켜야 하므로 고장난 서버를 대체할 새로운 서버를 구해 적용시킨다면, 다시 데이터를 가져야 하므로 Slave 한대는 복사해주는 작업에 몰두하게 된다. 그 시간동안 결국 Master-Slave 구조는 깨지게 된다.

  - 물론, 서버의 무정지가 필수 조건이지의 여부는 해당 애플리케이션의 용도에 따라 다르지만 기본적인 개념은 가지고 있어야 할 것이다.

> 파니셔닝의 상반관계
>
> - 좋은 점
>   - 부하가 내려간다.
>   - 국소성이 증가해서 캐시 효과가 높아진다.
> - 나쁜 점
>   - 운용이 복잡해진다. 고장확률이 높아진다.
>   - 운용이 복잡해지면 그만큼 경제적인 비용이 든다.
>   - 메모리는 요즘 싸다..
> - 파티셔닝은 어디까지나 마지막 카드



